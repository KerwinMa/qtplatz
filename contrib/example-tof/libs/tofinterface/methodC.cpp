// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.1.9
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_codegen.cpp:376


#include "methodC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "methodC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_AnalyzerMethod[] =
      {
        { "sampling_interval", &CORBA::_tc_long },
        { "resolving_power", &CORBA::_tc_long },
        { "number_of_average", &CORBA::_tc_long },
        { "matsuda_plate_voltage", &CORBA::_tc_double },
        { "va_pulse_voltage", &CORBA::_tc_double },
        { "potential_lift_pulse_voltage", &CORBA::_tc_double },
        { "einzel_voltage", &CORBA::_tc_double },
        { "detector_voltage", &CORBA::_tc_double },
        { "accelaration_voltage", &CORBA::_tc_double }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_AnalyzerMethod (
  ::CORBA::tk_struct,
  "IDL:TOF/AnalyzerMethod:1.0",
  "AnalyzerMethod",
  _tao_fields_TOF_AnalyzerMethod,
  9);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_AnalyzerMethod =
    &_tao_tc_TOF_AnalyzerMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::AnalyzerMethod::_tao_any_destructor (
    void *_tao_void_pointer)
{
  AnalyzerMethod *_tao_tmp_pointer =
    static_cast<AnalyzerMethod *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_FFTMethod[] =
      {
        { "nbrSamples", &CORBA::_tc_long },
        { "delay", &CORBA::_tc_double },
        { "freq", &CORBA::_tc_double },
        { "voffs", &CORBA::_tc_double },
        { "intens", &CORBA::_tc_double }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_FFTMethod (
  ::CORBA::tk_struct,
  "IDL:TOF/FFTMethod:1.0",
  "FFTMethod",
  _tao_fields_TOF_FFTMethod,
  5);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_FFTMethod =
    &_tao_tc_TOF_FFTMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::FFTMethod::_tao_any_destructor (
    void *_tao_void_pointer)
{
  FFTMethod *_tao_tmp_pointer =
    static_cast<FFTMethod *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_IonSource_EI_Method[] =
      {
        { "source_temp", &CORBA::_tc_double },
        { "interface_temp", &CORBA::_tc_double }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_IonSource_EI_Method (
  ::CORBA::tk_struct,
  "IDL:TOF/IonSource_EI_Method:1.0",
  "IonSource_EI_Method",
  _tao_fields_TOF_IonSource_EI_Method,
  2);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_IonSource_EI_Method =
    &_tao_tc_TOF_IonSource_EI_Method;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::IonSource_EI_Method::_tao_any_destructor (
    void *_tao_void_pointer)
{
  IonSource_EI_Method *_tao_tmp_pointer =
    static_cast<IonSource_EI_Method *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_IonSource_DART_Method[] =
      {
        { "source_temp", &CORBA::_tc_double },
        { "interface_temp", &CORBA::_tc_double },
        { "ionization_voltage", &CORBA::_tc_double }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_IonSource_DART_Method (
  ::CORBA::tk_struct,
  "IDL:TOF/IonSource_DART_Method:1.0",
  "IonSource_DART_Method",
  _tao_fields_TOF_IonSource_DART_Method,
  3);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_IonSource_DART_Method =
    &_tao_tc_TOF_IonSource_DART_Method;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::IonSource_DART_Method::_tao_any_destructor (
    void *_tao_void_pointer)
{
  IonSource_DART_Method *_tao_tmp_pointer =
    static_cast<IonSource_DART_Method *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_union\union_cs.cpp:79

TOF::IonSourceMethod::IonSourceMethod (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = TOF_C::eIonSource_Unknown;
}

TOF::IonSourceMethod::IonSourceMethod (const ::TOF::IonSourceMethod &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case TOF_C::eIonSource_DART:
    {
      this->u_.dart_ = u.u_.dart_;
    }
    break;
    case TOF_C::eIonSource_EI:
    {
      this->u_.ei_ = u.u_.ei_;
    }
    break;
    default:
    break;
  }
}

TOF::IonSourceMethod::~IonSourceMethod (void)
{
  // Finalize.
  this->_reset ();
}

void TOF::IonSourceMethod::_tao_any_destructor (void *_tao_void_pointer)
{
  IonSourceMethod *tmp =
    static_cast<IonSourceMethod *> (_tao_void_pointer);
  delete tmp;
}

TOF::IonSourceMethod &
TOF::IonSourceMethod::operator= (const ::TOF::IonSourceMethod &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case TOF_C::eIonSource_DART:
    {
      this->u_.dart_ = u.u_.dart_;
    }
    break;
    case TOF_C::eIonSource_EI:
    {
      this->u_.ei_ = u.u_.ei_;
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void TOF::IonSourceMethod::_reset (void)
{
  switch (this->disc_)
  {
    
    case TOF_C::eIonSource_DART:
      break;
    case TOF_C::eIonSource_EI:
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\union_typecode.cpp:67

static TAO::TypeCode::Case_T<TOF_C::eIonSource, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_TOF_IonSourceMethod__0 (TOF_C::eIonSource_DART, "dart", &TOF::_tc_IonSource_DART_Method);
static TAO::TypeCode::Case_T<TOF_C::eIonSource, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_TOF_IonSourceMethod__1 (TOF_C::eIonSource_EI, "ei", &TOF::_tc_IonSource_EI_Method);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_TOF_IonSourceMethod[] =
  {
    &_tao_cases_TOF_IonSourceMethod__0,
    &_tao_cases_TOF_IonSourceMethod__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_TOF_IonSourceMethod (
    "IDL:TOF/IonSourceMethod:1.0",
    "IonSourceMethod",
    &TOF_C::_tc_eIonSource,
    _tao_cases_TOF_IonSourceMethod,
    sizeof (_tao_cases_TOF_IonSourceMethod)/sizeof (_tao_cases_TOF_IonSourceMethod[0]),
    -1);
  

namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_IonSourceMethod =
    &_tao_tc_TOF_IonSourceMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_ControlMethod[] =
      {
        { "analyzer", &TOF::_tc_AnalyzerMethod },
        { "ionSource", &TOF::_tc_IonSourceMethod },
        { "fft", &TOF::_tc_FFTMethod }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_ControlMethod (
  ::CORBA::tk_struct,
  "IDL:TOF/ControlMethod:1.0",
  "ControlMethod",
  _tao_fields_TOF_ControlMethod,
  3);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_ControlMethod =
    &_tao_tc_TOF_ControlMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::ControlMethod::_tao_any_destructor (
    void *_tao_void_pointer)
{
  ControlMethod *_tao_tmp_pointer =
    static_cast<ControlMethod *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_TuneMethod[] =
      {
        { "resv", &CORBA::_tc_long },
        { "resv1", &CORBA::_tc_long },
        { "resv2", &CORBA::_tc_long },
        { "resv3", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_TuneMethod (
  ::CORBA::tk_struct,
  "IDL:TOF/TuneMethod:1.0",
  "TuneMethod",
  _tao_fields_TOF_TuneMethod,
  4);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_TuneMethod =
    &_tao_tc_TOF_TuneMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::TuneMethod::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TuneMethod *_tao_tmp_pointer =
    static_cast<TuneMethod *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_Configuration[] =
      {
        { "configured_", &CORBA::_tc_boolean },
        { "option_type", &CORBA::_tc_string },
        { "option_name", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_Configuration (
  ::CORBA::tk_struct,
  "IDL:TOF/Configuration:1.0",
  "Configuration",
  _tao_fields_TOF_Configuration,
  3);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_Configuration =
    &_tao_tc_TOF_Configuration;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::Configuration::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Configuration *_tao_tmp_pointer =
    static_cast<Configuration *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\sequence_cs.cpp:73

#if !defined (_TOF_CONFIGURATION_SEQUENCE_CS_)
#define _TOF_CONFIGURATION_SEQUENCE_CS_

TOF::configuration_sequence::configuration_sequence (void)
{}

TOF::configuration_sequence::configuration_sequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        Configuration
      > (max)
{}

TOF::configuration_sequence::configuration_sequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    TOF::Configuration * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        Configuration
      >
    (max, length, buffer, release)
{}

TOF::configuration_sequence::configuration_sequence (
    const configuration_sequence &seq)
  : ::TAO::unbounded_value_sequence<
        Configuration
      > (seq)
{}

TOF::configuration_sequence::~configuration_sequence (void)
{}

void TOF::configuration_sequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  configuration_sequence * _tao_tmp_pointer =
    static_cast<configuration_sequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\alias_typecode.cpp:51



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:466


#ifndef _TAO_TYPECODE_TOF_configuration_sequence_GUARD
#define _TAO_TYPECODE_TOF_configuration_sequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        TOF_configuration_sequence_0 (
          ::CORBA::tk_sequence,
          &TOF::_tc_Configuration,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_TOF_configuration_sequence_0 =
        &TOF_configuration_sequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_TOF_configuration_sequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_TOF_configuration_sequence (
    ::CORBA::tk_alias,
    "IDL:TOF/configuration_sequence:1.0",
    "configuration_sequence",
    &TAO::TypeCode::tc_TOF_configuration_sequence_0);
  

namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_configuration_sequence =
    &_tao_tc_TOF_configuration_sequence;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:466

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_DeviceId[] =
      {
        { "manufacturer", &CORBA::_tc_string },
        { "revision", &CORBA::_tc_string },
        { "configurations", &TOF::_tc_configuration_sequence }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_DeviceId (
  ::CORBA::tk_struct,
  "IDL:TOF/DeviceId:1.0",
  "DeviceId",
  _tao_fields_TOF_DeviceId,
  3);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_DeviceId =
    &_tao_tc_TOF_DeviceId;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::DeviceId::_tao_any_destructor (
    void *_tao_void_pointer)
{
  DeviceId *_tao_tmp_pointer =
    static_cast<DeviceId *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_acqSegment[] =
      {
        { "startIndex", &CORBA::_tc_ushort },
        { "numberOfAverage", &CORBA::_tc_ushort },
        { "waitTime", &CORBA::_tc_ulong },
        { "numberOfSamples", &CORBA::_tc_ushort },
        { "stepOf", &CORBA::_tc_ushort }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_acqSegment (
  ::CORBA::tk_struct,
  "IDL:TOF/acqSegment:1.0",
  "acqSegment",
  _tao_fields_TOF_acqSegment,
  5);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_acqSegment =
    &_tao_tc_TOF_acqSegment;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::acqSegment::_tao_any_destructor (
    void *_tao_void_pointer)
{
  acqSegment *_tao_tmp_pointer =
    static_cast<acqSegment *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\sequence_cs.cpp:73

#if !defined (_TOF_ACQSEGMENT_SEQUENCE_CS_)
#define _TOF_ACQSEGMENT_SEQUENCE_CS_

TOF::acqSegment_sequence::acqSegment_sequence (void)
{}

TOF::acqSegment_sequence::acqSegment_sequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        acqSegment
      > (max)
{}

TOF::acqSegment_sequence::acqSegment_sequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    TOF::acqSegment * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        acqSegment
      >
    (max, length, buffer, release)
{}

TOF::acqSegment_sequence::acqSegment_sequence (
    const acqSegment_sequence &seq)
  : ::TAO::unbounded_value_sequence<
        acqSegment
      > (seq)
{}

TOF::acqSegment_sequence::~acqSegment_sequence (void)
{}

void TOF::acqSegment_sequence::_tao_any_destructor (
    void * _tao_void_pointer)
{
  acqSegment_sequence * _tao_tmp_pointer =
    static_cast<acqSegment_sequence *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\alias_typecode.cpp:51



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:466


#ifndef _TAO_TYPECODE_TOF_acqSegment_sequence_GUARD
#define _TAO_TYPECODE_TOF_acqSegment_sequence_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        TOF_acqSegment_sequence_0 (
          ::CORBA::tk_sequence,
          &TOF::_tc_acqSegment,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_TOF_acqSegment_sequence_0 =
        &TOF_acqSegment_sequence_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_TOF_acqSegment_sequence_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_TOF_acqSegment_sequence (
    ::CORBA::tk_alias,
    "IDL:TOF/acqSegment_sequence:1.0",
    "acqSegment_sequence",
    &TAO::TypeCode::tc_TOF_acqSegment_sequence_0);
  

namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_acqSegment_sequence =
    &_tao_tc_TOF_acqSegment_sequence;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\struct_typecode.cpp:88



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_typecode\typecode_defn.cpp:466

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TOF_acqMethod[] =
      {
        { "methodId", &CORBA::_tc_ulong },
        { "segments", &TOF::_tc_acqSegment_sequence }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TOF_acqMethod (
  ::CORBA::tk_struct,
  "IDL:TOF/acqMethod:1.0",
  "acqMethod",
  _tao_fields_TOF_acqMethod,
  2);


namespace TOF
{
  ::CORBA::TypeCode_ptr const _tc_acqMethod =
    &_tao_tc_TOF_acqMethod;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\structure_cs.cpp:59

void
TOF::acqMethod::_tao_any_destructor (
    void *_tao_void_pointer)
{
  acqMethod *_tao_tmp_pointer =
    static_cast<acqMethod *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::AnalyzerMethod &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::AnalyzerMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::AnalyzerMethod>::insert_copy (
          _tao_any,
          ::TOF::AnalyzerMethod::_tao_any_destructor,
          ::TOF::_tc_AnalyzerMethod,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::AnalyzerMethod *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::AnalyzerMethod>::insert (
        _tao_any,
        ::TOF::AnalyzerMethod::_tao_any_destructor,
        ::TOF::_tc_AnalyzerMethod,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::AnalyzerMethod *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::AnalyzerMethod *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::AnalyzerMethod *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::AnalyzerMethod>::extract (
          _tao_any,
          ::TOF::AnalyzerMethod::_tao_any_destructor,
          ::TOF::_tc_AnalyzerMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::AnalyzerMethod &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::AnalyzerMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::AnalyzerMethod>::insert_copy (
      _tao_any,
      TOF::AnalyzerMethod::_tao_any_destructor,
      TOF::_tc_AnalyzerMethod,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::AnalyzerMethod *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::AnalyzerMethod>::insert (
    _tao_any,
    TOF::AnalyzerMethod::_tao_any_destructor,
    TOF::_tc_AnalyzerMethod,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::AnalyzerMethod *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::AnalyzerMethod *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::AnalyzerMethod *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::AnalyzerMethod>::extract (
      _tao_any,
      TOF::AnalyzerMethod::_tao_any_destructor,
      TOF::_tc_AnalyzerMethod,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::FFTMethod &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::FFTMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::FFTMethod>::insert_copy (
          _tao_any,
          ::TOF::FFTMethod::_tao_any_destructor,
          ::TOF::_tc_FFTMethod,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::FFTMethod *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::FFTMethod>::insert (
        _tao_any,
        ::TOF::FFTMethod::_tao_any_destructor,
        ::TOF::_tc_FFTMethod,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::FFTMethod *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::FFTMethod *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::FFTMethod *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::FFTMethod>::extract (
          _tao_any,
          ::TOF::FFTMethod::_tao_any_destructor,
          ::TOF::_tc_FFTMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::FFTMethod &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::FFTMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::FFTMethod>::insert_copy (
      _tao_any,
      TOF::FFTMethod::_tao_any_destructor,
      TOF::_tc_FFTMethod,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::FFTMethod *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::FFTMethod>::insert (
    _tao_any,
    TOF::FFTMethod::_tao_any_destructor,
    TOF::_tc_FFTMethod,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::FFTMethod *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::FFTMethod *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::FFTMethod *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::FFTMethod>::extract (
      _tao_any,
      TOF::FFTMethod::_tao_any_destructor,
      TOF::_tc_FFTMethod,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::IonSource_EI_Method &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::IonSource_EI_Method *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::IonSource_EI_Method>::insert_copy (
          _tao_any,
          ::TOF::IonSource_EI_Method::_tao_any_destructor,
          ::TOF::_tc_IonSource_EI_Method,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::IonSource_EI_Method *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::IonSource_EI_Method>::insert (
        _tao_any,
        ::TOF::IonSource_EI_Method::_tao_any_destructor,
        ::TOF::_tc_IonSource_EI_Method,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::IonSource_EI_Method *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::IonSource_EI_Method *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::IonSource_EI_Method *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::IonSource_EI_Method>::extract (
          _tao_any,
          ::TOF::IonSource_EI_Method::_tao_any_destructor,
          ::TOF::_tc_IonSource_EI_Method,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::IonSource_EI_Method &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::IonSource_EI_Method *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::IonSource_EI_Method>::insert_copy (
      _tao_any,
      TOF::IonSource_EI_Method::_tao_any_destructor,
      TOF::_tc_IonSource_EI_Method,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::IonSource_EI_Method *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::IonSource_EI_Method>::insert (
    _tao_any,
    TOF::IonSource_EI_Method::_tao_any_destructor,
    TOF::_tc_IonSource_EI_Method,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::IonSource_EI_Method *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::IonSource_EI_Method *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::IonSource_EI_Method *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::IonSource_EI_Method>::extract (
      _tao_any,
      TOF::IonSource_EI_Method::_tao_any_destructor,
      TOF::_tc_IonSource_EI_Method,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::IonSource_DART_Method &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::IonSource_DART_Method *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::IonSource_DART_Method>::insert_copy (
          _tao_any,
          ::TOF::IonSource_DART_Method::_tao_any_destructor,
          ::TOF::_tc_IonSource_DART_Method,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::IonSource_DART_Method *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::IonSource_DART_Method>::insert (
        _tao_any,
        ::TOF::IonSource_DART_Method::_tao_any_destructor,
        ::TOF::_tc_IonSource_DART_Method,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::IonSource_DART_Method *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::IonSource_DART_Method *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::IonSource_DART_Method *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::IonSource_DART_Method>::extract (
          _tao_any,
          ::TOF::IonSource_DART_Method::_tao_any_destructor,
          ::TOF::_tc_IonSource_DART_Method,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::IonSource_DART_Method &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::IonSource_DART_Method *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::IonSource_DART_Method>::insert_copy (
      _tao_any,
      TOF::IonSource_DART_Method::_tao_any_destructor,
      TOF::_tc_IonSource_DART_Method,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::IonSource_DART_Method *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::IonSource_DART_Method>::insert (
    _tao_any,
    TOF::IonSource_DART_Method::_tao_any_destructor,
    TOF::_tc_IonSource_DART_Method,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::IonSource_DART_Method *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::IonSource_DART_Method *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::IonSource_DART_Method *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::IonSource_DART_Method>::extract (
      _tao_any,
      TOF::IonSource_DART_Method::_tao_any_destructor,
      TOF::_tc_IonSource_DART_Method,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_union\any_op_cs.cpp:40


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::IonSourceMethod &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::IonSourceMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::IonSourceMethod>::insert_copy (
          _tao_any,
          ::TOF::IonSourceMethod::_tao_any_destructor,
          ::TOF::_tc_IonSourceMethod,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TOF::IonSourceMethod *_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::TOF::IonSourceMethod>::insert (
        _tao_any,
        ::TOF::IonSourceMethod::_tao_any_destructor,
        ::TOF::_tc_IonSourceMethod,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::IonSourceMethod *&_tao_elem
    )
  {
    return _tao_any >>= const_cast<
        const ::TOF::IonSourceMethod *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::IonSourceMethod *&_tao_elem
    )
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::IonSourceMethod>::extract (
          _tao_any,
          ::TOF::IonSourceMethod::_tao_any_destructor,
          ::TOF::_tc_IonSourceMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TOF::IonSourceMethod &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::IonSourceMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::IonSourceMethod>::insert_copy (
        _tao_any,
        TOF::IonSourceMethod::_tao_any_destructor,
        TOF::_tc_IonSourceMethod,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TOF::IonSourceMethod *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TOF::IonSourceMethod>::insert (
      _tao_any,
      TOF::IonSourceMethod::_tao_any_destructor,
      TOF::_tc_IonSourceMethod,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TOF::IonSourceMethod *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const TOF::IonSourceMethod *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TOF::IonSourceMethod *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TOF::IonSourceMethod>::extract (
        _tao_any,
        TOF::IonSourceMethod::_tao_any_destructor,
        TOF::_tc_IonSourceMethod,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::ControlMethod &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::ControlMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::ControlMethod>::insert_copy (
          _tao_any,
          ::TOF::ControlMethod::_tao_any_destructor,
          ::TOF::_tc_ControlMethod,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::ControlMethod *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::ControlMethod>::insert (
        _tao_any,
        ::TOF::ControlMethod::_tao_any_destructor,
        ::TOF::_tc_ControlMethod,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::ControlMethod *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::ControlMethod *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::ControlMethod *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::ControlMethod>::extract (
          _tao_any,
          ::TOF::ControlMethod::_tao_any_destructor,
          ::TOF::_tc_ControlMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::ControlMethod &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::ControlMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::ControlMethod>::insert_copy (
      _tao_any,
      TOF::ControlMethod::_tao_any_destructor,
      TOF::_tc_ControlMethod,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::ControlMethod *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::ControlMethod>::insert (
    _tao_any,
    TOF::ControlMethod::_tao_any_destructor,
    TOF::_tc_ControlMethod,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::ControlMethod *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::ControlMethod *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::ControlMethod *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::ControlMethod>::extract (
      _tao_any,
      TOF::ControlMethod::_tao_any_destructor,
      TOF::_tc_ControlMethod,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::TuneMethod &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::TuneMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::TuneMethod>::insert_copy (
          _tao_any,
          ::TOF::TuneMethod::_tao_any_destructor,
          ::TOF::_tc_TuneMethod,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::TuneMethod *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::TuneMethod>::insert (
        _tao_any,
        ::TOF::TuneMethod::_tao_any_destructor,
        ::TOF::_tc_TuneMethod,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::TuneMethod *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::TuneMethod *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::TuneMethod *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::TuneMethod>::extract (
          _tao_any,
          ::TOF::TuneMethod::_tao_any_destructor,
          ::TOF::_tc_TuneMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::TuneMethod &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::TuneMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::TuneMethod>::insert_copy (
      _tao_any,
      TOF::TuneMethod::_tao_any_destructor,
      TOF::_tc_TuneMethod,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::TuneMethod *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::TuneMethod>::insert (
    _tao_any,
    TOF::TuneMethod::_tao_any_destructor,
    TOF::_tc_TuneMethod,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::TuneMethod *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::TuneMethod *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::TuneMethod *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::TuneMethod>::extract (
      _tao_any,
      TOF::TuneMethod::_tao_any_destructor,
      TOF::_tc_TuneMethod,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::Configuration &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::Configuration *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::Configuration>::insert_copy (
          _tao_any,
          ::TOF::Configuration::_tao_any_destructor,
          ::TOF::_tc_Configuration,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::Configuration *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::Configuration>::insert (
        _tao_any,
        ::TOF::Configuration::_tao_any_destructor,
        ::TOF::_tc_Configuration,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::Configuration *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::Configuration *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::Configuration *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::Configuration>::extract (
          _tao_any,
          ::TOF::Configuration::_tao_any_destructor,
          ::TOF::_tc_Configuration,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::Configuration &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::Configuration *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::Configuration>::insert_copy (
      _tao_any,
      TOF::Configuration::_tao_any_destructor,
      TOF::_tc_Configuration,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::Configuration *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::Configuration>::insert (
    _tao_any,
    TOF::Configuration::_tao_any_destructor,
    TOF::_tc_Configuration,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::Configuration *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::Configuration *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::Configuration *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::Configuration>::extract (
      _tao_any,
      TOF::Configuration::_tao_any_destructor,
      TOF::_tc_Configuration,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\any_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::configuration_sequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::configuration_sequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::configuration_sequence>::insert_copy (
          _tao_any,
          ::TOF::configuration_sequence::_tao_any_destructor,
          ::TOF::_tc_configuration_sequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TOF::configuration_sequence *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::configuration_sequence>::insert (
        _tao_any,
        ::TOF::configuration_sequence::_tao_any_destructor,
        ::TOF::_tc_configuration_sequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::configuration_sequence *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::configuration_sequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::configuration_sequence *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::configuration_sequence>::extract (
          _tao_any,
          ::TOF::configuration_sequence::_tao_any_destructor,
          ::TOF::_tc_configuration_sequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TOF::configuration_sequence &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::configuration_sequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::configuration_sequence>::insert_copy (
        _tao_any,
        TOF::configuration_sequence::_tao_any_destructor,
        TOF::_tc_configuration_sequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TOF::configuration_sequence *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::configuration_sequence>::insert (
      _tao_any,
      TOF::configuration_sequence::_tao_any_destructor,
      TOF::_tc_configuration_sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TOF::configuration_sequence *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::configuration_sequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TOF::configuration_sequence *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::configuration_sequence>::extract (
        _tao_any,
        TOF::configuration_sequence::_tao_any_destructor,
        TOF::_tc_configuration_sequence,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::DeviceId &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::DeviceId *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::DeviceId>::insert_copy (
          _tao_any,
          ::TOF::DeviceId::_tao_any_destructor,
          ::TOF::_tc_DeviceId,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::DeviceId *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::DeviceId>::insert (
        _tao_any,
        ::TOF::DeviceId::_tao_any_destructor,
        ::TOF::_tc_DeviceId,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::DeviceId *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::DeviceId *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::DeviceId *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::DeviceId>::extract (
          _tao_any,
          ::TOF::DeviceId::_tao_any_destructor,
          ::TOF::_tc_DeviceId,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::DeviceId &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::DeviceId *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::DeviceId>::insert_copy (
      _tao_any,
      TOF::DeviceId::_tao_any_destructor,
      TOF::_tc_DeviceId,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::DeviceId *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::DeviceId>::insert (
    _tao_any,
    TOF::DeviceId::_tao_any_destructor,
    TOF::_tc_DeviceId,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::DeviceId *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::DeviceId *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::DeviceId *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::DeviceId>::extract (
      _tao_any,
      TOF::DeviceId::_tao_any_destructor,
      TOF::_tc_DeviceId,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::acqSegment &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::acqSegment *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::acqSegment>::insert_copy (
          _tao_any,
          ::TOF::acqSegment::_tao_any_destructor,
          ::TOF::_tc_acqSegment,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::acqSegment *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::acqSegment>::insert (
        _tao_any,
        ::TOF::acqSegment::_tao_any_destructor,
        ::TOF::_tc_acqSegment,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::acqSegment *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::acqSegment *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::acqSegment *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::acqSegment>::extract (
          _tao_any,
          ::TOF::acqSegment::_tao_any_destructor,
          ::TOF::_tc_acqSegment,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::acqSegment &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::acqSegment *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::acqSegment>::insert_copy (
      _tao_any,
      TOF::acqSegment::_tao_any_destructor,
      TOF::_tc_acqSegment,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::acqSegment *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::acqSegment>::insert (
    _tao_any,
    TOF::acqSegment::_tao_any_destructor,
    TOF::_tc_acqSegment,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::acqSegment *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::acqSegment *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::acqSegment *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::acqSegment>::extract (
      _tao_any,
      TOF::acqSegment::_tao_any_destructor,
      TOF::_tc_acqSegment,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\any_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::acqSegment_sequence &_tao_elem
    )
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::acqSegment_sequence *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::acqSegment_sequence>::insert_copy (
          _tao_any,
          ::TOF::acqSegment_sequence::_tao_any_destructor,
          ::TOF::_tc_acqSegment_sequence,
          _tao_elem
        );
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::TOF::acqSegment_sequence *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::acqSegment_sequence>::insert (
        _tao_any,
        ::TOF::acqSegment_sequence::_tao_any_destructor,
        ::TOF::_tc_acqSegment_sequence,
        _tao_elem
      );
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::acqSegment_sequence *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::acqSegment_sequence *&> (
        _tao_elem
      );
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::acqSegment_sequence *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::acqSegment_sequence>::extract (
          _tao_any,
          ::TOF::acqSegment_sequence::_tao_any_destructor,
          ::TOF::_tc_acqSegment_sequence,
          _tao_elem
        );
  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const TOF::acqSegment_sequence &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::acqSegment_sequence *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::acqSegment_sequence>::insert_copy (
        _tao_any,
        TOF::acqSegment_sequence::_tao_any_destructor,
        TOF::_tc_acqSegment_sequence,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    TOF::acqSegment_sequence *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::acqSegment_sequence>::insert (
      _tao_any,
      TOF::acqSegment_sequence::_tao_any_destructor,
      TOF::_tc_acqSegment_sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    TOF::acqSegment_sequence *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::acqSegment_sequence *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const TOF::acqSegment_sequence *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::acqSegment_sequence>::extract (
        _tao_any,
        TOF::acqSegment_sequence::_tao_any_destructor,
        TOF::_tc_acqSegment_sequence,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\any_op_cs.cpp:46



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace TOF
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::TOF::acqMethod &_tao_elem)
  {
    if (0 == &_tao_elem) // Trying to de-reference NULL object
      _tao_any <<= static_cast< ::TOF::acqMethod *>( 0 ); // Use non-copying insertion of a NULL
    else
      TAO::Any_Dual_Impl_T< ::TOF::acqMethod>::insert_copy (
          _tao_any,
          ::TOF::acqMethod::_tao_any_destructor,
          ::TOF::_tc_acqMethod,
          _tao_elem);
  }

  /// Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any, ::
      TOF::acqMethod *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::TOF::acqMethod>::insert (
        _tao_any,
        ::TOF::acqMethod::_tao_any_destructor,
        ::TOF::_tc_acqMethod,
        _tao_elem);
  }

  /// Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::TOF::acqMethod *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::TOF::acqMethod *&> (
        _tao_elem);
  }

  /// Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::TOF::acqMethod *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::TOF::acqMethod>::extract (
          _tao_any,
          ::TOF::acqMethod::_tao_any_destructor,
          ::TOF::_tc_acqMethod,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TOF::acqMethod &_tao_elem)
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<TOF::acqMethod *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<TOF::acqMethod>::insert_copy (
      _tao_any,
      TOF::acqMethod::_tao_any_destructor,
      TOF::_tc_acqMethod,
      _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TOF::acqMethod *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TOF::acqMethod>::insert (
    _tao_any,
    TOF::acqMethod::_tao_any_destructor,
    TOF::_tc_acqMethod,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  TOF::acqMethod *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const TOF::acqMethod *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TOF::acqMethod *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<TOF::acqMethod>::extract (
      _tao_any,
      TOF::acqMethod::_tao_any_destructor,
      TOF::_tc_acqMethod,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::AnalyzerMethod &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.sampling_interval) &&
    (strm << _tao_aggregate.resolving_power) &&
    (strm << _tao_aggregate.number_of_average) &&
    (strm << _tao_aggregate.matsuda_plate_voltage) &&
    (strm << _tao_aggregate.va_pulse_voltage) &&
    (strm << _tao_aggregate.potential_lift_pulse_voltage) &&
    (strm << _tao_aggregate.einzel_voltage) &&
    (strm << _tao_aggregate.detector_voltage) &&
    (strm << _tao_aggregate.accelaration_voltage);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::AnalyzerMethod &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.sampling_interval) &&
    (strm >> _tao_aggregate.resolving_power) &&
    (strm >> _tao_aggregate.number_of_average) &&
    (strm >> _tao_aggregate.matsuda_plate_voltage) &&
    (strm >> _tao_aggregate.va_pulse_voltage) &&
    (strm >> _tao_aggregate.potential_lift_pulse_voltage) &&
    (strm >> _tao_aggregate.einzel_voltage) &&
    (strm >> _tao_aggregate.detector_voltage) &&
    (strm >> _tao_aggregate.accelaration_voltage);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::FFTMethod &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.nbrSamples) &&
    (strm << _tao_aggregate.delay) &&
    (strm << _tao_aggregate.freq) &&
    (strm << _tao_aggregate.voffs) &&
    (strm << _tao_aggregate.intens);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::FFTMethod &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.nbrSamples) &&
    (strm >> _tao_aggregate.delay) &&
    (strm >> _tao_aggregate.freq) &&
    (strm >> _tao_aggregate.voffs) &&
    (strm >> _tao_aggregate.intens);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::IonSource_EI_Method &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.source_temp) &&
    (strm << _tao_aggregate.interface_temp);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::IonSource_EI_Method &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.source_temp) &&
    (strm >> _tao_aggregate.interface_temp);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::IonSource_DART_Method &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.source_temp) &&
    (strm << _tao_aggregate.interface_temp) &&
    (strm << _tao_aggregate.ionization_voltage);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::IonSource_DART_Method &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.source_temp) &&
    (strm >> _tao_aggregate.interface_temp) &&
    (strm >> _tao_aggregate.ionization_voltage);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_union\cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::IonSourceMethod &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case TOF_C::eIonSource_DART:
      {
        result = strm << _tao_union.dart ();
      }
      break;
    case TOF_C::eIonSource_EI:
      {
        result = strm << _tao_union.ei ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::IonSourceMethod &_tao_union
  )
{
  TOF_C::eIonSource _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case TOF_C::eIonSource_DART:
      {
        TOF::IonSource_DART_Method _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.dart (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case TOF_C::eIonSource_EI:
      {
        TOF::IonSource_EI_Method _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.ei (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::ControlMethod &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.analyzer) &&
    (strm << _tao_aggregate.ionSource) &&
    (strm << _tao_aggregate.fft);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::ControlMethod &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.analyzer) &&
    (strm >> _tao_aggregate.ionSource) &&
    (strm >> _tao_aggregate.fft);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::TuneMethod &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.resv) &&
    (strm << _tao_aggregate.resv1) &&
    (strm << _tao_aggregate.resv2) &&
    (strm << _tao_aggregate.resv3);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::TuneMethod &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.resv) &&
    (strm >> _tao_aggregate.resv1) &&
    (strm >> _tao_aggregate.resv2) &&
    (strm >> _tao_aggregate.resv3);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::Configuration &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.configured_)) &&
    (strm << _tao_aggregate.option_type.in ()) &&
    (strm << _tao_aggregate.option_name.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::Configuration &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.configured_)) &&
    (strm >> _tao_aggregate.option_type.out ()) &&
    (strm >> _tao_aggregate.option_name.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_TOF_configuration_sequence_CPP_
#define _TAO_CDR_OP_TOF_configuration_sequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::configuration_sequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::configuration_sequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_TOF_configuration_sequence_CPP_ */

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::DeviceId &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.manufacturer.in ()) &&
    (strm << _tao_aggregate.revision.in ()) &&
    (strm << _tao_aggregate.configurations);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::DeviceId &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.manufacturer.out ()) &&
    (strm >> _tao_aggregate.revision.out ()) &&
    (strm >> _tao_aggregate.configurations);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::acqSegment &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.startIndex) &&
    (strm << _tao_aggregate.numberOfAverage) &&
    (strm << _tao_aggregate.waitTime) &&
    (strm << _tao_aggregate.numberOfSamples) &&
    (strm << _tao_aggregate.stepOf);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::acqSegment &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.startIndex) &&
    (strm >> _tao_aggregate.numberOfAverage) &&
    (strm >> _tao_aggregate.waitTime) &&
    (strm >> _tao_aggregate.numberOfSamples) &&
    (strm >> _tao_aggregate.stepOf);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_sequence\cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_TOF_acqSegment_sequence_CPP_
#define _TAO_CDR_OP_TOF_acqSegment_sequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::acqSegment_sequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::acqSegment_sequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_TOF_acqSegment_sequence_CPP_ */

// TAO_IDL - Generated from
// c:\users\toshi\src\vc11\ace_wrappers\tao\tao_idl\be\be_visitor_structure\cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TOF::acqMethod &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.methodId) &&
    (strm << _tao_aggregate.segments);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TOF::acqMethod &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.methodId) &&
    (strm >> _tao_aggregate.segments);
}

TAO_END_VERSIONED_NAMESPACE_DECL



