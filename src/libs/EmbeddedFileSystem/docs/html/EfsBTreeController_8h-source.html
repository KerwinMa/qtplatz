<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EmbeddedFileSystem: EfsBTreeController.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>EfsBTreeController.h</h1><div class="fragment"><pre>00001 
00002 
00003 
00004 
00005 
00006 
00007 
00008 
00009 <span class="preprocessor">#ifndef __EfsBTreeController_h__</span>
00010 <span class="preprocessor"></span><span class="preprocessor">#define __EfsBTreeController_h__</span>
00011 <span class="preprocessor"></span>
00012 <span class="preprocessor">#include "BTreeNode.h"</span>
00013 <span class="preprocessor">#include &lt;map&gt;</span>
00014 
00015 <span class="keyword">class </span><a class="code" href="classEfs.html">Efs</a>;
00016 
00017 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00018 <span class="keyword">class </span>EfsBTreeController
00019 {
00020 <span class="keyword">public</span>:
00021 
00022         <span class="keyword">typedef</span> <a class="code" href="classBTreeNode.html">BTreeNode&lt; NodeSize, KeyT, DataT &gt;</a> NodeType;
00023 
00026         EfsBTreeController();
00027 
00030         <span class="keywordtype">bool</span> setFS( <a class="code" href="classEfs.html">Efs</a> *afs, <span class="keywordtype">int</span> rootOffset, <span class="keywordtype">int</span> blockSize );
00031 
00034         <span class="keywordtype">bool</span> isOpen() <span class="keyword">const</span>;
00035 
00036         <span class="keywordtype">void</span> releaseNode( <span class="keywordtype">int</span> addr );
00037         guint cacheSize() <span class="keyword">const</span>;
00038         <span class="keywordtype">void</span> setMaxCacheSize( guint maxSize );
00039         <span class="keywordtype">bool</span> nodeInCache( <span class="keywordtype">int</span> addr );
00040 
00041 <span class="keyword">protected</span>:
00042 
00045         <span class="keywordtype">bool</span> initRoot();
00046 
00047         <span class="comment">// Storage related operations</span>
00048         NodeType* newNode();
00049         <span class="keywordtype">void</span> deleteNode( NodeType *node );
00050         <span class="keywordtype">bool</span> loadNode( NodeType **node, <span class="keywordtype">int</span> addr );
00051         <span class="keywordtype">void</span> saveNode( NodeType *node );
00052         <span class="keywordtype">void</span> releaseCache( <span class="keywordtype">bool</span> saveAll = <span class="keyword">true</span> );
00053         <span class="keywordtype">int</span> rootAddr();
00054         <span class="keywordtype">void</span> rootAddr( <span class="keywordtype">int</span> addr );
00055 
00056         <span class="keywordtype">void</span> closeController();
00057 
00058         <span class="comment">// Data</span>
00059         NodeType *root_;
00060         <a class="code" href="classEfs.html">Efs</a> *efs_;
00061         <span class="keywordtype">int</span> rootAddr_;
00062         <span class="keywordtype">int</span> rootOffset_;
00063         <span class="keywordtype">int</span> preferAddr_;
00064         <span class="keywordtype">int</span> nodeBlockCount_;
00065 
00066         <span class="keyword">typedef</span> std::map&lt; int, NodeType* &gt; ChunkCacheMap;
00067         ChunkCacheMap cache_;
00068 };
00069 
00070 <span class="comment">//      ===================================================================</span>
00071 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::EfsBTreeController</span>
00072 
00073 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00074 EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::EfsBTreeController() : 
00075         root_( 0 ),
00076         efs_( 0 ),
00077         rootAddr_( 0 ),
00078         rootOffset_( 0 ),
00079         nodeBlockCount_( 0 )
00080 {}
00081 
00082 <span class="comment">//      ===================================================================</span>
00083 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::open</span>
00084 
00085 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00086 <span class="keywordtype">bool</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::setFS( <a class="code" href="classEfs.html">Efs</a> *afs, <span class="keywordtype">int</span> rootOffset, <span class="keywordtype">int</span> blockSize )
00087 {
00088         efs_ = afs;
00089         rootOffset_ = rootOffset;
00090 
00091         <span class="keyword">const</span> <span class="keywordtype">int</span> nodeSize = <span class="keyword">sizeof</span>( NodeType );
00092         nodeBlockCount_ = ( nodeSize / blockSize ) + ( ( nodeSize % blockSize ) &gt; 0 );
00093 
00094         <span class="keywordflow">return</span> initRoot();
00095 }
00096 
00097 <span class="comment">//      ===================================================================</span>
00098 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::newNode</span>
00099 
00100 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00101 <span class="keyword">typename</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::NodeType* EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::newNode()
00102 {
00103         <span class="keywordflow">if</span> ( !efs_-&gt;ensureSpace( nodeBlockCount_ ) )
00104         {
00105                 <span class="keywordflow">return</span> 0;
00106         }
00107 
00108         EfsFragmentList fragments;
00109         <span class="keywordflow">if</span> ( !efs_-&gt;smartAllocate( 0, nodeBlockCount_, EfsAllocService, fragments ) )
00110         {
00111                 <span class="keywordflow">return</span> 0;
00112         }
00113 
00114         <span class="keywordflow">if</span> ( fragments.empty() )
00115         {
00116                 <span class="keywordflow">return</span> 0;
00117         }
00118 
00119         NodeType *newnode = <span class="keyword">new</span> NodeType();
00120         newnode-&gt;addr_ = fragments.begin()-&gt;addr;
00121 
00122         saveNode( newnode );
00123         cache_[ newnode-&gt;addr_ ] = newnode;
00124 
00125         <span class="keywordflow">return</span> newnode;
00126 }
00127 
00128 <span class="comment">//      ===================================================================</span>
00129 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::deleteNode</span>
00130 
00131 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00132 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::deleteNode( NodeType* node )
00133 {
00134         <span class="keyword">typename</span> ChunkCacheMap::iterator iter = cache_.find( node-&gt;addr_ );
00135 
00136         <span class="keywordflow">if</span> ( iter != cache_.end() )
00137         {
00138                 cache_.erase( iter );
00139         }
00140 
00141         efs_-&gt;deallocateSpace( node-&gt;addr_, nodeBlockCount_ );
00142         <span class="keyword">delete</span> node;
00143 }
00144 
00145 <span class="comment">//      ===================================================================</span>
00146 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::loadNode</span>
00147 
00148 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00149 <span class="keywordtype">bool</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::loadNode( NodeType **node, <span class="keywordtype">int</span> addr )
00150 {
00151         <span class="keywordflow">if</span> ( !addr )
00152         {
00153                 *node = 0;
00154                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00155         }
00156 
00157         <span class="keyword">typename</span> ChunkCacheMap::iterator iter = cache_.find( addr );
00158 
00159         <span class="keywordflow">if</span> ( iter == cache_.end() )
00160         {
00161                 *node = <span class="keyword">new</span> NodeType();
00162                 <span class="keywordflow">if</span> ( !efs_-&gt;readBlock( addr, ( <span class="keywordtype">char</span>* ) *node, <span class="keyword">sizeof</span>( NodeType ), 0 ) )
00163                 {
00164                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00165                 }
00166 
00167                 <span class="keywordflow">if</span> ( addr == ( *node )-&gt;addr_ )
00168                 {
00169                         cache_[ addr ] = *node;
00170                 }
00171         }
00172         <span class="keywordflow">else</span>
00173         {
00174                 *node = iter-&gt;second;
00175         }
00176 
00177         <span class="keywordflow">if</span> ( ( *node )-&gt;addr_ != addr )
00178         {
00179                 <span class="comment">// Storage is corrupted!</span>
00180                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00181         }
00182 
00183         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00184 }
00185 
00186 <span class="comment">//      ===================================================================</span>
00187 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::saveNode</span>
00188 
00189 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00190 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::saveNode( NodeType *node )
00191 {
00192         efs_-&gt;writeBlock( node-&gt;addr_, ( <span class="keyword">const</span> <span class="keywordtype">char</span>* ) node, <span class="keyword">sizeof</span>( NodeType ), 0, <span class="keyword">false</span> );
00193 }
00194 
00195 <span class="comment">//      ===================================================================</span>
00196 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::releaseCache</span>
00197 
00198 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00199 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::releaseCache( <span class="keywordtype">bool</span> saveAll )
00200 {
00201         <span class="keyword">typename</span> ChunkCacheMap::iterator iter = cache_.begin();
00202 
00203         <span class="keywordflow">for</span> ( ; iter != cache_.end(); iter++ )
00204         {
00205                 <span class="keywordflow">if</span> ( saveAll )
00206                 {
00207                         saveNode( iter-&gt;second );
00208                 }
00209 
00210                 <span class="keywordflow">if</span> ( iter-&gt;second != root_ )
00211                 {
00212                         <span class="keyword">delete</span> iter-&gt;second;
00213                 }
00214         }
00215 
00216         cache_.clear();
00217         <span class="keywordflow">if</span> ( root_ )
00218         {
00219                 cache_[ root_-&gt;addr_ ] = root_;
00220         }
00221 }
00222 
00223 
00224 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00225 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::releaseNode( <span class="keywordtype">int</span> addr )
00226 {
00227         <span class="keyword">typename</span> ChunkCacheMap::iterator iter = cache_.find( addr );
00228 
00229         <span class="keywordflow">if</span> ( cache_.end() != iter )
00230         {
00231                 saveNode( iter-&gt;second );
00232 
00233                 <span class="keywordflow">if</span> ( iter-&gt;second != root_ )
00234                 {
00235                         <span class="keyword">delete</span> iter-&gt;second;
00236                         cache_.erase( iter );
00237                 }
00238         }
00239 }
00240 
00241 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00242 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::setMaxCacheSize( guint )
00243 {}
00244 
00245 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00246 <span class="keywordtype">bool</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::nodeInCache( <span class="keywordtype">int</span> addr )
00247 {
00248         <span class="keywordflow">return</span> cache_.end() != cache_.find( addr );
00249 }
00250 
00251 <span class="comment">//      ===================================================================</span>
00252 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::rootAddr</span>
00253 
00254 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00255 <span class="keywordtype">int</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::rootAddr()
00256 {
00257         <span class="keywordflow">if</span> ( rootAddr_ )
00258         {
00259                 <span class="keywordflow">return</span> rootAddr_;
00260         }
00261 
00262         efs_-&gt;fs_-&gt;seek( rootOffset_ );
00263         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( rootAddr_ ) != efs_-&gt;fs_-&gt;read( ( <span class="keywordtype">char</span>* ) &amp;rootAddr_, <span class="keyword">sizeof</span>( rootAddr_ ) ) )
00264         {
00265                 <span class="keywordflow">return</span> 0;
00266         }
00267 
00268         <span class="keywordflow">return</span> rootAddr_;
00269 }
00270 
00271 <span class="comment">//      ===================================================================</span>
00272 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::rootAddr</span>
00273 
00274 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00275 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::rootAddr( <span class="keywordtype">int</span> addr )
00276 {
00277         efs_-&gt;fs_-&gt;seek( rootOffset_ );
00278         efs_-&gt;fs_-&gt;write( ( <span class="keyword">const</span> <span class="keywordtype">char</span>* ) &amp;addr, <span class="keyword">sizeof</span>( addr ) );
00279         rootAddr_ = addr;
00280 }
00281 
00282 <span class="comment">//      ===================================================================</span>
00283 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::closeController</span>
00284 
00285 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00286 <span class="keywordtype">void</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::closeController()
00287 {
00288         cache_.clear();
00289         efs_ = 0;
00290         rootAddr_ = 0;
00291         rootOffset_ = 0;
00292         nodeBlockCount_ = 0;
00293 }
00294 
00295 <span class="comment">//      ===================================================================</span>
00296 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::isOpen</span>
00297 
00298 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00299 <span class="keywordtype">bool</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::isOpen()<span class="keyword"> const</span>
00300 <span class="keyword"></span>{
00301         <span class="keywordflow">return</span> ( root_ != 0 );
00302 }
00303 
00304 <span class="comment">//      ===================================================================</span>
00305 <span class="comment">//      EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::initRoot</span>
00306 
00307 <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> NodeSize, <span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> DataT &gt;
00308 <span class="keywordtype">bool</span> EfsBTreeController&lt; NodeSize, KeyT, DataT &gt;::initRoot()
00309 {
00310         <span class="keywordtype">int</span> addr = rootAddr();
00311 
00312         <span class="keywordflow">if</span> ( !addr )
00313         {
00314                 <span class="comment">// Root is empty</span>
00315                 root_ = newNode();
00316                 <span class="keywordflow">if</span> ( !root_ )
00317                 {
00318                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00319                 }
00320 
00321                 rootAddr( root_-&gt;addr_ );
00322         }
00323         <span class="keywordflow">else</span>
00324         {
00325                 <span class="keywordflow">if</span> ( !loadNode( &amp;root_, addr ) )
00326                 {
00327                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00328                 }
00329         }
00330 
00331         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00332 }
00333 
00334 
00335 <span class="preprocessor">#endif // __EfsBTreeController_h__</span>
00336 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 18 11:38:49 2007 for EmbeddedFileSystem by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
